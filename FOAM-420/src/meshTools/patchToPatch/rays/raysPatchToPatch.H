/*---------------------------------------------------------------------------*\
|       o        |
|    o     o     |  FOAM (R) : Open-source CFD for Enterprise
|   o   O   o    |  Version : 4.2.0
|    o     o     |  ESI Ltd. <http://esi.com/>
|       o        |
\*---------------------------------------------------------------------------
License
    This file is part of FOAMcore.
    FOAMcore is based on OpenFOAM (R) <http://www.openfoam.org/>.

    FOAMcore is free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    FOAMcore is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License
    along with FOAMcore.  If not, see <http://www.gnu.org/licenses/>.

Copyright
    (c) 2021-2022 OpenFOAM Foundation
    (c) 2022 Esi Ltd.

Class
    Foam::patchToPatches::rays

Description
    Class to generate patchToPatch coupling geometry. Coupling is determined by
    means of comparing the bound boxes generated by the intersection method.
    This generates an outer "envelope" of possible intersections that can be
    used for ray shooting and Lagrangian transfer.

SourceFiles
    raysPatchToPatch.C

\*---------------------------------------------------------------------------*/

#ifndef raysPatchToPatch_H
#define raysPatchToPatch_H

#include "patchToPatch/patchToPatch/patchToPatch.H"

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

namespace Foam
{
namespace patchToPatches
{

/*---------------------------------------------------------------------------*\
                             Class rays Declaration
\*---------------------------------------------------------------------------*/

class rays
:
    public patchToPatch
{
    // Private Data

        // Parallel

            //- Cache of the part of the source patch local to the target
            autoPtr<PrimitiveOldTimePatch<faceList, pointField>>
                localSrcPatchPtr_;

            //- Cache of the part of the target patch local to the source
            autoPtr<PrimitiveOldTimePatch<faceList, pointField>>
                localTgtPatchPtr_;


    // Private Member Functions

        //- Get the bound box for a source face
        virtual treeBoundBox srcBox
        (
            const face& srcFace,
            const pointField& srcPoints,
            const vectorField& srcPointNormals
        ) const override;

        //- Intersect two faces
        virtual bool intersectFaces
        (
            const primitiveOldTimePatch& srcPatch,
            const vectorField& srcPointNormals,
            const vectorField& srcPointNormals0,
            const primitiveOldTimePatch& tgtPatch,
            const label srcFacei,
            const label tgtFacei
        ) override;

        //- Distribute the target patch so that enough is locally available
        //  for its intersection with the source patch can be computed
        virtual
        tmpNrc<PrimitiveOldTimePatch<faceList, pointField>>
        distributeTgt
        (
            const primitiveOldTimePatch& srcPatch,
            const vectorField& srcPointNormals,
            const vectorField& srcPointNormals0,
            const primitiveOldTimePatch& tgtPatch,
            mapDistribute& tgtMap
        ) override;

        //- Distribute the source patch so that everything the target
        //  intersects is locally available. Happens after intersection.
        virtual
        tmpNrc<PrimitiveOldTimePatch<faceList, pointField>>
        distributeSrc
        (
            const primitiveOldTimePatch& srcPatch,
            mapDistribute& srcMap
        ) override;

        //- Finalising
        virtual label finalise
        (
            const primitiveOldTimePatch& srcPatch,
            const vectorField& srcPointNormals,
            const vectorField& srcPointNormals0,
            const primitiveOldTimePatch& tgtPatch,
            const transformer& tgtToSrc
        ) override;

        //- Compute a ray intersection
        procFace ray
        (
            const primitiveOldTimePatch& outPatch,
            const autoPtr<PrimitiveOldTimePatch<faceList, pointField>>&
                localOutPatchPtr,
            const autoPtr<List<procFace>>& localOutProcFacesPtr,
            const List<DynamicList<label>>& inLocalOutFacesPtr,
            const scalar fraction,
            const label inFacei,
            const point& inP,
            const vector& inN,
            point& outP
        ) const;


public:

    //- Runtime type information
    TypeName("rays");


    // Constructors

        //- Construct from components
        rays(const bool reverse);


    //- Destructor
    ~rays();


    // Member Functions

        //- For each source face, the coupled target weights
        virtual tmpNrc<List<DynamicList<scalar>>> srcWeights
        (
            const primitivePatch& srcPatch
        ) const override;

        //- For each target face, the coupled source weights
        virtual tmpNrc<List<DynamicList<scalar>>> tgtWeights
        (
            const primitivePatch& tgtPatch
        ) const override;

        //- Compute a ray intersection from the source side to the target
        procFace srcToTgtRay
        (
            const primitiveOldTimePatch& tgtPatch,
            const scalar fraction,
            const label srcFacei,
            const vector& srcP,
            const vector& srcN,
            point& tgtP
        ) const;

        //- Compute a ray intersection from the target side to the source
        procFace tgtToSrcRay
        (
            const primitiveOldTimePatch& srcPatch,
            const scalar fraction,
            const label tgtFacei,
            const vector& tgtP,
            const vector& tgtN,
            point& srcP
        ) const;
};


// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

} // End namespace patchToPatches
} // End namespace Foam

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

#endif

// ************************************************************************* //
